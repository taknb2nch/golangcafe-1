その１
エラーは最初にチェックして深いネストを避けよう！
　　コンパイルしたら、同じようなコードになるんだろうけど、人間が見やすいかどうかが重要

その２
Writerとエラー、サイズなどを構造体に入れ、構造体内部で管理しよう！
　　構造体のエラーがあれば、何もせず処理を抜ける。
　　そうすることで、呼び出し側はWrite()するだけで済む。

その３
型によって処理が決まる場合は、型で処理を分岐させましょう！
　　引数をinterface{}で受け取り、switch文のv.(type)を使って、処理を分ける。
　　そうすることで、呼び出し側はキャストが不要になるし、コードも見やすくなる。

その４
switch文の:=の定義を使え！
　　型によって分岐させる時に、:=を使うと、値の取得と型の判定が両方できるようになる。
　　case文は型で判定され、xには、Type Assertion後の値が入る。

その５
全て書くか、なにも書かないかのどちらかにする。
　　bytes.Bufferに全ての書き込みデータを貯めておき、Flush()で実際に出力する。
　　今回のWrite()は再起呼び出しを使って、バッファへの出力を行っている。

その６
リクエストを処理し、エラーを返す関数と、エラーを受け取り、エラーを処理する関数に分ける！
　　複数の処理でエラーチェックを行うのではなく、エラーを戻り値として返し、エラー処理は1か所のまとめると見やすくなる。

その７
重要なコードは先頭に書くこと！
　　ライセンス情報、ビルドタグ、パッケージドキュメントを記載する。
　　import文は、（gofmtコマンドを実行すればいい気がするが…。）標準パッケージを最初に記述し、1行開けて、go getで取得したパッケージを記述する。
　　重要な型から始まり、ヘルパー関数などで終わるようにする。
　　　　ファイル名は型に合わせたものにした方が良い！という結論に至る。
　　　　　機能ごとにファイルを分けて、わかりやすくするべきなんだろう。

その８
　　パッケージ名の前に連想させるようなドキュメントを書くこと！
　　godocに出力されるものは、ドキュメントを書きましょう！

その９
　　短い事はいいこと。
　　意味がわかって、できるだけ短い名前をつけるようにしましょう！
　　"MarshalWithIndentation"よりも"MarshalIndent"という名前が好ましい。

　　識別子にパッケージ名が含まれる場合は、つける必要はない！
　　　　encoding/jsonにEncoderがあるが、JSONEncoderではない。
　　　　参照される時は、json.Encoderとなるから、必要ないでしょう？

その１０
　　１つのパッケージを複数に分けるべきか？
　　　　長いファイルは避けよう。
　　　　　　net/httpパッケージは15734行を47ファイルに分けている。
　　　　コードとテストは分けよう。
　　　　　　net/http/cookie.goとcookie_test.go

　　　　パッケージドキュメントをdoc.goに分けておくといい。
　　　　　　複数のファイルがある時に、どこにパッケージドキュメントを書くか迷う。
　　　　　　ファイルが１つの時はそのファイルの先頭に書けばいい。

その１１
　　go getができるようなパッケージを作りましょう。
　　　　ネットワークプロトコルを定義するようなパッケージは使われるかもしれない。
　　　　mainから始まるコマンドは再利用されないかもしれない。


その１２
　　必要なものを尋ねる。
　　　　Gopher型を使います。
　　　　
　　　　以下のメソッドを定義した。
　　　　func (g *Gopher) WriteToFile(f *os.File) (int64, error) {

　　　　しかし、テストがしにくい！
　　　　func (g *Gopher) WriteToReadWriter(rw io.ReadWriter) (int64, error) {

　　　　必要最低限のインターフェイスを使ってメソッドを定義すべきだ。
　　　　　　ファイルへの書き出し機能だけなので、Readerの機能は必要がないから、必要なものを求めること！
　　　　func (g *Gopher) WriteToWriter(f io.Writer) (int64, error) {


その１３
　　独立を保つ！パッケージごとに独立させておく。
　　　　parserは解析のみ。drawerは描画のみ。pngへのエンコードはエンコードのみにする。など。

　　　　依存するパッケージをimportするのではなくて、interfaceを使って、Parse機能を持った関数を受け取り、呼び出すようにしよう！

　　　　具体的な型を使うよりも、インターフェイスを使った方がテストが簡単に作れる。
　　　　　　TestFunc型はEval()を実装しているので、interfaceを実装していることになる。


その１４
　　APIで非同期にするのは避けよう！
　　　順番にAPIを利用したい時はどうすればいいのか？
　　　　同期APIを用意すると、並列実行が簡単に呼び出せる。
　　　　　（※runtime.GOMAXPROCS(2)とかすると、順番がおかしくなるが、呼び出し順をどうするか？という議論ではない！）


その１５
　　goroutineと通信するための構造体のメンバのChannelか、単体のChannelを使え！
　　　（chanのバッファが0の時は、他のGoroutinesがChannelを受け取らないとGoroutineがブロックされる。chanのバッファが1の時は、1個はバッファに置けるので、Goroutineがブロックされず、突き抜ける。）
　　

その１６
　　Buffered Channelを使って、goroutineのリークを避けよう！
　　　channelに書き込むと、goroutineはブロックされる。
　　　goroutineはchannelの参照を握る
　　　したがって、channelはガベージコレクトされることはない。

　　　goroutinesの切り替わりは「明示的なブロック」で発生するので、
　　　今回のようにバッファがないchannelだと、goroutineの切り替わりが発生するので、goroutineの処理が終わる前にchannelの受信待ちが終了してしまうことがある。すると、参照が残り、リークする。
　　　
その１７
　　quit chanを使って、goroutinesのリークを避けよう！
　　　close(quit)を行うと、channelに受信しない事が明示される。
　　　goroutineの切り替わりを意識したコードを書くことで、channelのリークを防ぐことができる。
     chan(struct{})はクローズ（終了）用なので、誰もChannelに送信できないようにするために、空の構造体にしている。
